# Data Structures and Performance

This repository contains the Starter Code, a GUI Application and code for the assignments of Course 2 'Data Structures and Performance' of the specialization 'Object Oriented Java Programming: Data Structures and Beyond' (https://www.coursera.org/learn/data-structures-optimizing-performance?specialization=java-object-oriented)

## Course Description

How do Java programs deal with vast quantities of data? Many of the data structures and algorithms that work with introductory toy examples break when applications process real, large data sets.  Efficiency is critical, but how do we achieve it, and how do we even measure it?

This is an intermediate Java course. We recommend this course to learners who have previous experience in software development or a background in computer science, and in particular, we recommend that you have taken the first course in this specialization (which also requires some previous experience with Java).  

In this course, you will use and analyze data structures that are used in industry-level applications, such as linked lists, trees, and hashtables.  You will explain how these data structures make programs more efficient and flexible.  You will apply asymptotic Big-O analysis to describe the performance of algorithms and evaluate which strategy to use for efficient data retrieval, addition of new data, deletion of elements, and/or memory usage.

The program you will build throughout this course allows its user to manage, manipulate and reason about large sets of textual data.  This is an intermediate Java course, and we will build on your prior knowledge.  This course is designed around  the same video series as in our first course in this specialization, including explanations of core content, learner videos, student and engineer testimonials, and support videos -- to better allow you to choose your own path through the course!

## Modules

### Module 1 - Introduction to the course

Welcome to the first module in the second course of our Intermediate Java Programming Specialization. We'll start with introductions again: to ourselves, the Google engineers, and the structure of the course. After the introduction we'll have a short warm up to get you comfortable with the code you will be building on to this class. But don't worry--no graded programming assignments yet. This week is all about getting comfortable and excited to learn.

### Module 2 - Working with Strings

This week we're going to dive into the course programming project. In the first lesson you'll learn about Strings and Regular Expressions, and in the programming assignment this week you'll apply that knowledge to adding functionality to your text editor so that it can measure the "readability" of text by calculating something called the "Flesch Readability Score". This course is focused on building code that not only does interesting things, but also finishes them quickly. So, let's get started building some code!

### Module 3 - Efficiency Analysis and Benchmarking

Welcome to week 3! The text-editor application you worked with last week does something, but it doesn't do it particularly fast. This week we'll start talking about efficiency. We'll introduce the concept of "Big-O" notation, which sounds a little silly, but is really a powerful (and extremely common) way of analyzing a program's efficiency, independent of the system that it's running on and the exact details of how it's implemented. Then we'll go the other direction and dive into the details, talking about how to measure the actual running time of a piece of code to get an idea of how it really performs in practice.

### Module 4 - Interfaces, Linked Lists vs. Arrays, and Correctness

This week we'll start talking about some of the basic concepts that one expects to find in a data structures course: the idea of data abstraction, and a data structure called a Linked List. Even though Linked Lists are not very efficient structures (for the most part), they do hit home the idea of "linking" pieces of data together in your computer's memory, rather than storing the data in one contiguous region. This linking idea will be central to many of the more advanced data structures, namely trees and graphs, that are coming up later in this course and in the next course in this specialization. In this module you'll also learn tools and procedures for unit testing your code, which is a way to make sure that what you've written is correct, and a staple practice of any sophisticated software developer.

### Module 5 - Trees! (including Binary Search Trees and Tries)

Welcome to week 4! We know you've been working hard. We hope you tried that optional Markov Text Generation programming assignment last week, but if not, no worries. You can always go back and do it later (spoiler alert: it's pretty amazing that such a simple algorithm can produce such realistic text). This week there's more fun (and hard work) as we learn about trees. Trees rely on the same linked structure idea as Linked Lists, only they're MUCH faster (usually...). In the project this week you'll add auto-complete to your text editor. Believe us when we say it's so cool when you get it working! You'll see... and we bet you can't wait for the programming assignment now. :)

### Module 6 - Hash Maps and Edit Distance

You made it to the last week! Congratulations on getting this far! In this last week we'll be looking at a fundamental data structure called a Hash Table. If you thought trees were fast, just wait until you see what Hash Tables can do! Your last programming assignment will add spelling correction suggestions to your text editor, and there's an optional assignment that builds on the same ideas as the main assignment too, if you have the time and energy.
